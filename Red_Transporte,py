import networkx as nx
import matplotlib.pyplot as plt
import heapq

class Poblacion:
    def __init__(self, nombre):
        self.nombre = nombre

class Conexion:
    def __init__(self, poblacion1, poblacion2, distancia):
        self.poblacion1 = poblacion1
        self.poblacion2 = poblacion2
        self.distancia = distancia

class GrafoCiudades:
    def __init__(self):
        self.poblaciones = {}
        self.conexiones = []
        self.bst = ArbolBusquedaBinaria()

    def agregar_poblacion(self, nombre):
        poblacion = Poblacion(nombre)
        self.poblaciones[nombre] = poblacion

    def agregar_conexion(self, nombre_poblacion1, nombre_poblacion2, distancia):
        poblacion1 = self.poblaciones[nombre_poblacion1]
        poblacion2 = self.poblaciones[nombre_poblacion2]
        conexion = Conexion(poblacion1, poblacion2, distancia)
        self.conexiones.append(conexion)
        self.bst.insertar(distancia, [poblacion1.nombre, poblacion2.nombre])

    def visualizar_grafo(self):
        G = nx.Graph()

        for poblacion in self.poblaciones.values():
            G.add_node(poblacion.nombre)

        for conexion in self.conexiones:
            G.add_edge(conexion.poblacion1.nombre, conexion.poblacion2.nombre, weight=conexion.distancia)

        pos = nx.spring_layout(G)
        etiquetas = nx.get_edge_attributes(G, 'weight')
        nx.draw(G, pos, with_labels=True, font_weight='bold')
        nx.draw_networkx_edge_labels(G, pos, edge_labels=etiquetas)
        plt.show()

    def ruta_mas_corta(self, origen, destino):
        distancias = {poblacion: float('inf') for poblacion in self.poblaciones}
        distancias[origen] = 0
        padres = {poblacion: None for poblacion in self.poblaciones}
        monticulo = [(0, origen)]

        while monticulo:
            dist_actual, poblacion_actual = heapq.heappop(monticulo)

            if dist_actual > distancias[poblacion_actual]:
                continue

            for conexion in self.conexiones:
                if conexion.poblacion1.nombre == poblacion_actual:
                    vecino = conexion.poblacion2.nombre
                elif conexion.poblacion2.nombre == poblacion_actual:
                    vecino = conexion.poblacion1.nombre
                else:
                    continue

                nueva_distancia = dist_actual + conexion.distancia

                if nueva_distancia < distancias[vecino]:
                    distancias[vecino] = nueva_distancia
                    padres[vecino] = poblacion_actual
                    heapq.heappush(monticulo, (nueva_distancia, vecino))

        ruta = []
        poblacion_actual = destino
        while poblacion_actual is not None:
            ruta.insert(0, poblacion_actual)
            poblacion_actual = padres[poblacion_actual]

        # Distancia total + RUTA
        distancia_total = distancias[destino]
        print(f'La ruta más corta que empieza en {origen} y termina en {destino} es: {ruta}. La distancia total es: {distancia_total}.')

    def arbol_recubrimiento_minimo(self):
        conexiones_ordenadas = sorted(self.conexiones, key=lambda conexion: conexion.distancia)
        conjunto_disjunto = {poblacion: poblacion for poblacion in self.poblaciones}
        arbol_recubrimiento = []

        def encontrar_conjunto(poblacion):
            if conjunto_disjunto[poblacion] != poblacion:
                conjunto_disjunto[poblacion] = encontrar_conjunto(conjunto_disjunto[poblacion])
            return conjunto_disjunto[poblacion]

        def unir_conjuntos(conjunto1, conjunto2):
            conjunto_disjunto[encontrar_conjunto(conjunto1)] = encontrar_conjunto(conjunto2)

        for conexion in conexiones_ordenadas:
            if encontrar_conjunto(conexion.poblacion1.nombre) != encontrar_conjunto(conexion.poblacion2.nombre):
                arbol_recubrimiento.append(conexion)
                unir_conjuntos(conexion.poblacion1.nombre, conexion.poblacion2.nombre)

        # Árbol de Recubrimiento Mínimo
        print("Árbol de Recubrimiento Mínimo:")
        for conexion in arbol_recubrimiento:
            print(f"{conexion.poblacion1.nombre} - {conexion.poblacion2.nombre}, Distancia: {conexion.distancia}")

    def crear_bst(self):
        for conexion in self.conexiones:
            self.bst.insertar(conexion.distancia, [conexion.poblacion1.nombre, conexion.poblacion2.nombre])
        self.bst.mostrar_distancias_ordenadas()

class ArbolBusquedaBinaria:
    def __init__(self):
        self.raiz = None

    def insertar(self, clave, valor):
        self.raiz = self._insertar(self.raiz, clave, valor)

    def _insertar(self, nodo, clave, valor):
        if nodo is None:
            return Nodo(clave, valor)
        if clave < nodo.clave:
            nodo.izquierda = self._insertar(nodo.izquierda, clave, valor)
        elif clave > nodo.clave:
            nodo.derecha = self._insertar(nodo.derecha, clave, valor)
        return nodo

    def mostrar_distancias_ordenadas(self):
        self._mostrar_distancias_ordenadas(self.raiz)

    def _mostrar_distancias_ordenadas(self, nodo):
        if nodo:
            self._mostrar_distancias_ordenadas(nodo.izquierda)
            print(f"Distancia: {nodo.clave}, Poblaciones: {nodo.valor}")
            self._mostrar_distancias_ordenadas(nodo.derecha)

class Nodo:
    def __init__(self, clave, valor):
        self.clave = clave
        self.valor = valor
        self.izquierda = None
        self.derecha = None

# Ejemplo de uso
mi_grafo_ciudades = GrafoCiudades()

# Agregar poblaciones
mi_grafo_ciudades.agregar_poblacion("BCN")
mi_grafo_ciudades.agregar_poblacion("MAD")
mi_grafo_ciudades.agregar_poblacion("VLC")
mi_grafo_ciudades.agregar_poblacion("SVQ")
mi_grafo_ciudades.agregar_poblacion("MAH")
mi_grafo_ciudades.agregar_poblacion("SCQ")

# Agregar conexiones con distancias
mi_grafo_ciudades.agregar_conexion("BCN", "MAD", 10)
mi_grafo_ciudades.agregar_conexion("MAD", "VLC", 6)
mi_grafo_ciudades.agregar_conexion("BCN", "VLC", 15)
mi_grafo_ciudades.agregar_conexion("MAH", "SCQ", 14)
mi_grafo_ciudades.agregar_conexion("MAH", "SVQ", 17)
mi_grafo_ciudades.agregar_conexion("VLC", "SVQ", 8)
mi_grafo_ciudades.agregar_conexion("MAD", "SVQ", 3)
mi_grafo_ciudades.agregar_conexion("BCN", "SVQ", 8)
mi_grafo_ciudades.agregar_conexion("VLC", "SCQ", 20)
mi_grafo_ciudades.agregar_conexion("SCQ", "SVQ", 4)

print("Estas son las ciudades por las que moverse: BCN - Barcelona, MAD - Madrid, VLC - Valencia, SVQ - Sevilla, MAH - Mahón, SCQ - Santiago.")
ciudad1 = input("Ciudad de donde sales: ")
ciudad2 = input("Ciudad donde llegas: ")

mi_grafo_ciudades.ruta_mas_corta(ciudad1, ciudad2)

mi_grafo_ciudades.visualizar_grafo()